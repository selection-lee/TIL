package com.am;

// 인터페이스
// 오직 추상메서드만을 갖는 추상 타입 (일종의 설계도나 명세서)
// - 다른 클래스들이 따라야 하는 규약을 정의
// "이 기능들을 구현해야 합니다"라는 약속을 정의하는 특별한 타입
// public, abstact 키워드 생략 가능, static 키워드 생략 가능
// 필드, 생성자 없다
// 1. 다형성 극대화
// 2. 협업
// 3. 인덱스의 형식을 취할 수도 있다
// 4. (코드적으로 보면?) 존재유무
// 5. 네이밍 축약
// 더 있지만 .. 
interface Inter05{} // 이렇게 생긴 인터페이스 상당히 많이 쓰인다
// -> 상속받아놓고 아무것도 할 게 없음
// -> 메서드가 없다 - 즉, 선언된 게 없다
// 어따쓰는 걸까? (1)
// - 클래스 이름 지을 때에는 그 클래스가 어떤 목적, 어떤 일 할 거라는 걸 암시하는 이름 지으라고 햇음.
// - 그럼 이름이 엄청 길어지겠지
// - 그 클래스에 필요한 키워드를 인터페이스로 빼ㅡㄴ 것
// -> 아무런 기능이 없지만, 클래스의 설명을 인터페이스로 대신하는 것
// 어차피 api 보면 무슨 클래스, 무슨 interface 상속받는지 다 보임
// 어따쓰는 걸까 (2)
// - 코드적으로 봤을 떄 다형성
// - 내가 호출을 하지 않을지라도 상속을 안했는데 작성한다고 하면?
// - 상속을 안 받았는데 캐스팅을 하면 오류가 남 - 동일한 인터페이스 상속하는 것들은 캐스팅해도 오류가 안 나겠네 -
// - 그럼 오류가 나는 클래스는 인터페이스 상속 안받는 거
// - 그럼 상속 받는애랑 안받는 애를 구분 가능
// - 그럼 뿌리가 같은 애들중에서 유사한 것끼리 묶고 싶어 - 그럼 캐스팅 인터페이스로 가능...
// - 구분 중요함
// - 기능이 필요한 게 아니고, 할지말지가 중요한 것. 이 인터페이스 상속 여부로 객체를 구분할 수 잇게 됨
//

interface Inter01{
    public static int su1 = 1111;
    // 필드가 없기 때문에 static 키워드 생략 가능
    public int su2 = 2222;
    int su3 = 333;// 마찬가지로 접근 제한하는 데 의미가 없음 그래서 public 생략 가능
    public abstract void func01();
    // 추상 -> 상속을 통해 쓴다
    // > 접근을 제한하면 안 된다. 객체도 없으니까. 안그럼 존재의 의미가 없어짐
    // 그래서 public 생략 가능
    // 생략햇다고 해서 default가 아님@!!!
    // public void func02(){}; // 구현을 가질 수 없다
    public void func02();
    void func03(); // public!!!!!!!!!
}

interface Inter02{
    void func01();
}
interface Inter03{
    void func02();
}
// interface가 클래스를 상속받진 못하지만(부모클래스생성자 등 생성자 호출 불가(?)여서)
// interface끼리 상속은 가능
//interface Inter04 extends Inter02, Inter03 {
//    void func03();
//}

// interface의 상속은 extends 아니고 implements
// 그 순간 추상메서드 오버라이드 필수
public class Ex04 implements Inter02, Inter03{
    public static void main(String[] args) {
        // 그럼 interface의 의미는 뭘까?
        // 다형성 극대화
        // 기본적으로 다중상속을 허용하지 않다보니까 부모클래스 타입으로 다형성 할 수 있는데
        // 부모클래스 루트가 특정화되어버림. 쭉 타고내려와야해서.
        // 다중상속의 효과를 지니게 됨
        // 여러갈래로. 다중상속 불가지만 다중상속처럼 할 수 있게 되는 것.
        // 만들어지는 건 이것 때문에 만들ㅇ러졌지만, 그게 전부가 아님. 인터페이스의 활용은 열려있다.
        // 특징 보고 이렇게 쓰면 되겠다고 알아서 쓰면 됨
        Ex04 me = new Ex04(); // 이렇게 할 수도 잇지만,,
        me.func01();
        Object me2 = new Ex04(); // 다형성에 따라서 부모클래스인 object 타입으로 만들 수도있고
        // me2.func01(); // 불가
        Inter02 me3 = new Ex04(); // interface 로 선언(?) 했기떄문에 ㅑnter로도 가능
        me3.func01();;
        Inter03 me4 = new Ex04();
        me4.func02();

    }
    @Override
    public void func01() {

    }
    @Override
    public void func02(){}
}
